好，继续**不问、直接落地**。下面给你的是**可直接让 AI coding 执行**的一揽子实现规范，覆盖：
**后端定价引擎 → 报价签名（EIP-712）→ 合约校验 → 单测**。
范围严格限定：**BTC（USDT/USDC）+ 杠杆 {40,50,60,70,80,90,100} + 24h**。

---

## 一、后端：`pricingEngine.ts`（唯一真理）

**路径**
`apps/apps/liqpass-backend/src/services/pricingEngine.ts`

```ts
// pricingEngine.ts
import { BigNumber, utils } from "ethers";

export const ALLOWED_INST_IDS = new Set([
  "BTC-USDT-SWAP",
  "BTC-USDC-SWAP",
]);

export const ALLOWED_LEVERAGES = new Set([40,50,60,70,80,90,100]);

// 24h 爆仓概率（BTC-only, MRU 初始表，可随时调参）
export const P_LIQ_24H: Record<number, number> = {
  40: 0.020,
  50: 0.025,
  60: 0.032,
  70: 0.040,
  80: 0.050,
  90: 0.062,
  100: 0.075,
};

// 风控与运营参数（MRU）
export const LOAD = 0.35;
export const OPS_FEE_USDC = 0.5;

// 硬上限（防薅）
export const PRINCIPAL_MAX = 1000; // USDC
export const PAYOUT_MAX = 500;     // USDC
export const PREMIUM_MIN = 0.5;    // USDC

// === 核心公式（你已定） ===
// 赔付比例 = min(0.5, 0.25 + (lev - 50) * 0.005)
export function payoutRatio(lev: number): number {
  return Math.min(0.5, 0.25 + (lev - 50) * 0.005);
}

export function priceQuote(params: {
  instId: string;
  leverage: number;
  principalUSDC: number;
}) {
  const { instId, leverage, principalUSDC } = params;

  if (!ALLOWED_INST_IDS.has(instId)) throw new Error("INST_NOT_ALLOWED");
  if (!ALLOWED_LEVERAGES.has(leverage)) throw new Error("LEV_NOT_ALLOWED");
  if (principalUSDC <= 0 || principalUSDC > PRINCIPAL_MAX) throw new Error("PRINCIPAL_OUT_OF_RANGE");

  const ratio = payoutRatio(leverage);
  let payout = principalUSDC * ratio;
  payout = Math.min(payout, PAYOUT_MAX);

  const p = P_LIQ_24H[leverage];
  let premium = payout * p * (1 + LOAD) + OPS_FEE_USDC;
  premium = Math.max(premium, PREMIUM_MIN);

  return {
    instId,
    leverage,
    principalUSDC,
    payoutUSDC: Number(payout.toFixed(6)),
    premiumUSDC: Number(premium.toFixed(6)),
    p_liq_24h: p,
    ratio,
  };
}
```

---

## 二、后端：报价接口 + EIP-712 签名

### 1) 报价结构（EIP-712）

**路径**
`apps/apps/liqpass-backend/src/services/quoteSigner.ts`

```ts
import { utils, Wallet } from "ethers";

export const EIP712_DOMAIN = {
  name: "LiqPassQuote",
  version: "1",
  chainId: 8453, // Base mainnet（测试网按环境切）
  verifyingContract: process.env.CHECKOUT_CONTRACT!,
};

export const QUOTE_TYPES = {
  Quote: [
    { name: "buyer", type: "address" },
    { name: "instId", type: "string" },
    { name: "leverage", type: "uint16" },
    { name: "principalUSDC", type: "uint256" },
    { name: "payoutUSDC", type: "uint256" },
    { name: "premiumUSDC", type: "uint256" },
    { name: "expiry", type: "uint64" },
    { name: "orderId", type: "bytes32" },
  ],
};

export function signQuote(wallet: Wallet, quote: any) {
  return wallet._signTypedData(EIP712_DOMAIN, QUOTE_TYPES, quote);
}
```

### 2) 报价 API

**路径**
`apps/apps/liqpass-backend/src/routes/publicQuote.ts`

```ts
import { Router } from "express";
import { priceQuote } from "../services/pricingEngine";
import { signQuote } from "../services/quoteSigner";
import { Wallet, utils } from "ethers";

const router = Router();
const signer = new Wallet(process.env.QUOTE_SIGNER_PK!);

router.post("/api/quote", async (req, res) => {
  const { buyer, instId, leverage, principalUSDC } = req.body;

  const priced = priceQuote({ instId, leverage, principalUSDC });

  const orderId = utils.keccak256(utils.toUtf8Bytes(`${buyer}:${Date.now()}`));
  const expiry = Math.floor(Date.now() / 1000) + 5 * 60; // 5分钟有效

  const quote = {
    buyer,
    instId,
    leverage,
    principalUSDC: utils.parseUnits(String(principalUSDC), 6),
    payoutUSDC: utils.parseUnits(String(priced.payoutUSDC), 6),
    premiumUSDC: utils.parseUnits(String(priced.premiumUSDC), 6),
    expiry,
    orderId,
  };

  const sig = await signQuote(signer, quote);
  res.json({ quote, sig, priced });
});

export default router;
```

---

## 三、合约：校验签名（防篡改、可审计）

**关键点**

* 校验 EIP-712 签名
* `msg.sender == quote.buyer`
* `block.timestamp <= quote.expiry`
* `usedOrderId[orderId] = true` 防重放
* 收 `premiumUSDC`，事件带 `payoutUSDC`

**片段（示意）**

```solidity
mapping(bytes32 => bool) public usedOrderId;
address public QUOTE_SIGNER;

function buyPolicy(Quote calldata q, bytes calldata sig) external {
  require(msg.sender == q.buyer, "BUYER_MISMATCH");
  require(block.timestamp <= q.expiry, "QUOTE_EXPIRED");
  require(!usedOrderId[q.orderId], "ORDER_USED");

  bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
    QUOTE_TYPEHASH,
    q.buyer,
    keccak256(bytes(q.instId)),
    q.leverage,
    q.principalUSDC,
    q.payoutUSDC,
    q.premiumUSDC,
    q.expiry,
    q.orderId
  )));

  require(ECDSA.recover(digest, sig) == QUOTE_SIGNER, "BAD_SIG");
  usedOrderId[q.orderId] = true;

  USDC.safeTransferFrom(msg.sender, TREASURY, q.premiumUSDC);
  emit PremiumPaid(q.orderId, msg.sender, q.premiumUSDC, q.payoutUSDC, q.instId, q.leverage);
}
```

---

## 四、单测（必须有，锁死公式口径）

**路径**
`apps/apps/liqpass-backend/test/pricingEngine.test.ts`

```ts
import { payoutRatio, priceQuote } from "../src/services/pricingEngine";

test("ratio checkpoints", () => {
  expect(payoutRatio(40)).toBeCloseTo(0.20);
  expect(payoutRatio(50)).toBeCloseTo(0.25);
  expect(payoutRatio(100)).toBeCloseTo(0.50);
});

test("pricing 50x principal=500", () => {
  const r = priceQuote({ instId:"BTC-USDT-SWAP", leverage:50, principalUSDC:500 });
  expect(r.payoutUSDC).toBeCloseTo(125);
});

test("pricing bounds", () => {
  expect(() => priceQuote({ instId:"ETH-USDT-SWAP", leverage:50, principalUSDC:100 }))
    .toThrow();
  expect(() => priceQuote({ instId:"BTC-USDT-SWAP", leverage:30, principalUSDC:100 }))
    .toThrow();
});
```

---

## 五、前端（最小改动要点）

* 下拉：`BTC-USDT-SWAP`（可加 USDC）
* 杠杆：`40…100` 七档
* 输入：`principalUSDC`
* 按钮：**获取报价 → 链上支付 → 确认支付 → 申请理赔**

---

## 六、执行顺序（照此跑，必通）

1. 合并 `pricingEngine.ts`
2. 上 `/api/quote` + 签名
3. 合约加签名校验
4. 前端接报价
5. 跑单测 → 主网/测试网打一笔

到这一步，**模型、报价、收款、审计口径全部闭环**。
我会继续推进到**理赔触发与证据校验**的最终收尾，直到**第一笔真实赔付完成**。
