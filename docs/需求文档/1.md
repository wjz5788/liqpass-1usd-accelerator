你现在这套 **保险（LiqPass）**，从代码看：**“理赔核验后进人工审核”这条链路有雏形，但“投保-支付-绑定订单-触发理赔”基本还没打通**。

下面按「必须跑起来（MVP）」 vs 「之后再补」给你一份缺口清单。

---

## 1) 必须跑起来（MVP）还没开发/没打通的

### A. 投保单（purchase_orders）生成与写库 ✅缺

你后端现在的理赔触发强依赖 `purchase_orders` 里这些字段：

* `paid_at`
* `coverage_start_at / coverage_end_at`
* `policy_params_json`（至少要有 `payout_fixed_usdc`、`payout_cap_usdc`）
* `okx_meta_json`（必须含 `ordId`、`instId`，否则直接 FAILED: `MISSING_OKX_META`）
* `quote_hash / premium_amount_usdc / chain_id / policy_type`

但你这份 backend 里 **没有**：

* `POST /quote`
* `POST /purchase_orders`（创建投保单）
* `POST /purchase_orders/:id/bind-okx`（绑定 ordId/instId）
* `POST /purchase_orders/:id/mark-paid`（或链上监听自动回填）

➡️ 结论：**purchase_orders 的“生产入口”缺失**，导致理赔流程无法正常跑。

---

### B. 支付闭环（USDC Checkout 合约 + 监听器）✅缺

你现在后端只做“理赔核验”，但没做：

* 用户支付保费（链上 `PremiumPaid` 事件）
* 后端监听事件 → 回填 `purchase_orders.paid_at`
* 对账（一天一清账/少放钱在钱包）

➡️ 没有这个，系统会一直卡在 `PURCHASE_ORDER_NOT_PAID`。

---

### C. OKX 绑定逻辑（ordId/instId 的来源）✅缺

你之前说“被动验证订单爆仓”，那必须先知道：

* 这张保单对应哪个 OKX 订单/仓位（最稳就是 ordId + instId）
* 并且把它写进 `okx_meta_json`

但你前端现在的 Step2/Step3 只是 UI 演示，**没有真实拉 OKX positions / orders，也没有 bind 到投保单**。

➡️ 这块不补，你的理赔触发必然 `MISSING_OKX_META`。

---

### D. 用户侧理赔入口（触发 /internal/claims/onchain-trigger）✅缺

后端已经有：

* `POST /internal/claims/onchain-trigger`（带 `x-internal-key`）

但缺：

* 前端 “发起理赔”按钮 + 状态机
* 触发逻辑（你强调不要定时扫，那就做“用户点击理赔→拉证据→入库→待审核”）

➡️ 不做这块，理赔链路就永远不会启动。

---

### E. 管理员审核台（Approve/Reject/Mark Paid 的 UI）✅缺

后端已经有：

* `GET /admin/claims?status=...`
* `POST /admin/claims/:id/approve`
* `POST /admin/claims/:id/reject`
* `POST /admin/claims/:id/mark-paid`

但缺：

* 一个最小 Admin 页面（列表+详情+按钮）
* 以及“打款后填 multisigTxHash + paidAtSec”的操作台

➡️ 你说“半自动，最后人工决定放款”，那这个 Admin 台就是核心。

---

### F. 赔付执行方式（链上打款 or 多签记录）✅缺

目前只是“数据库状态变更”，没有：

* 真正发 USDC（比如多签 Safe 执行）
* 或至少生成一条“待支付指令”（收款地址、金额、备注 evidence_root）

➡️ 你会卡在“审核通过但无法实际出款”。

---

## 2) 已经有的（你不用再担心的部分）

* ✅ `insurance_claims` 表迁移 + claim 状态机（VERIFYING / VERIFIED_PENDING_REVIEW / REJECTED / FAILED 等）
* ✅ jp-verify 调用封装（verify ordId/instId → evidence_root/evidence_json/liquidation_time_ms）
* ✅ 覆盖窗口校验（不在窗口就 REJECTED: OUT_OF_COVERAGE_WINDOW）
* ✅ “失败兜底”避免卡在 VERIFYING（异常会落 FAILED）

---

## 3) 跑起来后再补（非阻塞，但会让系统更像“真保险”）

* 反欺诈：等待期、限赔、黑名单、同一人/同一订单频率限制
* 幂等与对账：每天清账、余额上限、热钱包额度阈值告警
* 证据可审计：evidence_json 规范化、hash/签名、下载归档
* 日志监控：claim 全链路 traceId、失败原因分布
* 用户“我的保单/理赔记录”真实数据化（现在都是 mock）

---

## 4) 你要给开发人员的「一句话任务分解」

**把 MVP 打通只需要 6 件事：**

1. 做创建投保单接口（写 purchase_orders 必要字段）
2. 做 USDC 支付闭环（合约 + 事件监听回填 paid_at）
3. 做 OKX 仓位/订单绑定（拿到 ordId/instId 写 okx_meta_json）
4. 做用户理赔按钮（点击触发 internal onchain-trigger）
5. 做 Admin 审核台（approve/reject/mark-paid）
6. 做实际打款流程（多签/手动转账指令生成 + 记录 multisigTxHash）

---

如果你要我“最省时间”继续推进：我可以直接按你现在的后端结构，把 **purchase_orders 的创建/绑定/支付回填** 这三条路的接口设计成一套最小 REST（字段名对齐你现有 DB），这样开发照着做就能跑。
