你这个报告很清楚：**框架齐了，卡在 4 个 DB 函数**（getApiAccount / createOrGetBinding / createPurchaseOrder / markOrderPaid）。
现在最务实的推进就是：**把“订单闭环”打通到能收钱且可对账**，别先做复杂定价。

下面我给你一套 **最小可跑、可上线前再加固** 的实现：**表结构 + 4 个函数代码 + 幂等/唯一约束**。你照着抄进仓库，就能把 Step3/Step4 跑通。

---

# 1) 先把三张表补齐（最小闭环）

## 1.1 api_accounts（存 OKX 只读 API）

> Secret 必须加密存

```sql
-- 003_create_api_accounts.sql
create table if not exists api_accounts (
  id bigserial primary key,
  user_id text not null,
  exchange text not null,                 -- 'OKX'
  uid text,                               -- OKX UID (可选但推荐)
  api_key text not null,
  secret_enc text not null,
  passphrase_enc text not null,
  label text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_api_accounts_user on api_accounts(user_id);
create unique index if not exists uniq_api_accounts_user_exchange_key
  on api_accounts(user_id, exchange, api_key);
```

## 1.2 insured_bindings（绑定键：instId+mgnMode+posSide）

```sql
-- 004_create_insured_bindings.sql
create table if not exists insured_bindings (
  id bigserial primary key,
  user_id text not null,
  api_account_id bigint not null references api_accounts(id) on delete cascade,
  exchange text not null,                 -- 'OKX'
  inst_id text not null,
  mgn_mode text not null,                 -- 'isolated'|'cross'
  pos_side text not null,                 -- 'long'|'short'|'net'
  sku text not null,                      -- 'LIQPASS_8H' etc
  status text not null default 'DRAFT',   -- DRAFT|ACTIVE|EXPIRED|CANCELLED
  bound_at timestamptz not null default now(),
  coverage_start_at timestamptz,
  coverage_end_at timestamptz
);

-- 防重复：同一绑定键在 DRAFT/ACTIVE 只能有一条
create unique index if not exists uniq_binding_active
on insured_bindings(api_account_id, inst_id, mgn_mode, pos_side)
where status in ('DRAFT','ACTIVE');
```

## 1.3 purchase_orders（投保订单）

```sql
-- 005_create_purchase_orders_minimal.sql
create table if not exists purchase_orders (
  id bigserial primary key,
  user_id text not null,
  binding_id bigint not null references insured_bindings(id) on delete cascade,
  purchase_order_id text not null,        -- bytes32 hex string: 0x...
  premium_amount text not null,           -- USDC 最小单位字符串
  premium_usd text not null,              -- "3.00"
  status text not null default 'DRAFT',   -- DRAFT|PAID_PENDING_CONFIRM|ACTIVE|EXPIRED|CANCELLED
  coverage_delay_sec int not null default 600,
  coverage_start_at timestamptz,
  coverage_end_at timestamptz,
  pay_tx_hash text,
  payer text,
  created_at timestamptz not null default now()
);

create unique index if not exists uniq_purchase_order_id
  on purchase_orders(purchase_order_id);

create unique index if not exists uniq_pay_tx_hash
  on purchase_orders(pay_tx_hash) where pay_tx_hash is not null;
```

---

# 2) 加密工具：AES-GCM（别用可逆明文）

你后端只要有一个环境变量：

* `API_KEYS_ENC_KEY`：32 字节随机 key（base64）

```ts
// src/security/cryptoBox.ts
import crypto from "crypto";

const KEY = Buffer.from(process.env.API_KEYS_ENC_KEY || "", "base64");
if (KEY.length !== 32) throw new Error("API_KEYS_ENC_KEY must be 32 bytes base64");

export function encrypt(plain: string) {
  const iv = crypto.randomBytes(12);
  const cipher = crypto.createCipheriv("aes-256-gcm", KEY, iv);
  const enc = Buffer.concat([cipher.update(plain, "utf8"), cipher.final()]);
  const tag = cipher.getAuthTag();
  return Buffer.concat([iv, tag, enc]).toString("base64"); // iv(12)+tag(16)+cipher
}

export function decrypt(b64: string) {
  const buf = Buffer.from(b64, "base64");
  const iv = buf.subarray(0, 12);
  const tag = buf.subarray(12, 28);
  const enc = buf.subarray(28);
  const decipher = crypto.createDecipheriv("aes-256-gcm", KEY, iv);
  decipher.setAuthTag(tag);
  const plain = Buffer.concat([decipher.update(enc), decipher.final()]);
  return plain.toString("utf8");
}
```

---

# 3) 你缺的 4 个函数：直接给实现（pg）

假设你已经有 `pg` 连接池：

```ts
// src/db/pool.ts
import { Pool } from "pg";
export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
```

---

## 3.1 getApiAccount（解密后给 okxClient 用）

```ts
// src/db/apiAccountsRepo.ts
import { pool } from "./pool";
import { decrypt } from "../security/cryptoBox";

export async function getApiAccount(apiAccountId: string) {
  const { rows } = await pool.query(
    `select id, user_id, exchange, uid, api_key, secret_enc, passphrase_enc
     from api_accounts where id = $1`,
    [apiAccountId]
  );
  if (rows.length === 0) throw new Error("API_ACCOUNT_NOT_FOUND");

  const r = rows[0];
  return {
    id: String(r.id),
    userId: r.user_id,
    exchange: r.exchange,
    uid: r.uid,
    apiKey: r.api_key,
    secret: decrypt(r.secret_enc),
    passphrase: decrypt(r.passphrase_enc),
  };
}
```

> 你 routes/insurance.ts 里的 `getApiAccount` 直接换成这个即可。

---

## 3.2 createOrGetBinding（幂等：唯一键冲突就取回）

```ts
// src/db/bindingsRepo.ts
import { pool } from "./pool";

export async function createOrGetBinding(input: {
  userId: string;
  apiAccountId: string;
  exchange: "OKX";
  instId: string;
  mgnMode: string;
  posSide: string;
  sku: string;
}) {
  const { userId, apiAccountId, exchange, instId, mgnMode, posSide, sku } = input;

  // 先插入，冲突则不插，随后 select 拿回
  await pool.query(
    `insert into insured_bindings(user_id, api_account_id, exchange, inst_id, mgn_mode, pos_side, sku, status)
     values($1,$2,$3,$4,$5,$6,$7,'DRAFT')
     on conflict on constraint uniq_binding_active do nothing`,
    [userId, apiAccountId, exchange, instId, mgnMode, posSide, sku]
  );

  const { rows } = await pool.query(
    `select id, status from insured_bindings
     where api_account_id=$1 and inst_id=$2 and mgn_mode=$3 and pos_side=$4
       and status in ('DRAFT','ACTIVE')
     limit 1`,
    [apiAccountId, instId, mgnMode, posSide]
  );
  if (rows.length === 0) throw new Error("BIND_CREATE_FAILED");

  return { bindId: String(rows[0].id), status: rows[0].status };
}
```

---

## 3.3 createPurchaseOrder（生成 purchaseOrderId bytes32 + 写入 DRAFT）

建议：purchaseOrderId 用 **keccak256(userId+bindId+nonce+time)** 生成，保证唯一且前端直接用。

```ts
// src/db/purchaseOrdersRepo.ts
import { pool } from "./pool";
import crypto from "crypto";

function genPurchaseOrderIdHex() {
  // 32 bytes -> 0x...
  return "0x" + crypto.randomBytes(32).toString("hex");
}

export async function createPurchaseOrder(input: {
  userId: string;
  bindId: string;
  premiumUsd: string;
  premiumAmount: string;     // USDC 最小单位
  coverageDelaySec: number;  // 600
  durationSec: number;       // 8h/24h/30d
}) {
  const purchaseOrderId = genPurchaseOrderIdHex();
  const now = new Date();
  const start = new Date(now.getTime() + input.coverageDelaySec * 1000);
  const end = new Date(start.getTime() + input.durationSec * 1000);

  const { rows } = await pool.query(
    `insert into purchase_orders(
        user_id, binding_id, purchase_order_id,
        premium_amount, premium_usd,
        coverage_delay_sec, coverage_start_at, coverage_end_at, status
     )
     values($1,$2,$3,$4,$5,$6,$7,$8,'DRAFT')
     returning id, purchase_order_id, premium_amount, premium_usd, coverage_delay_sec, coverage_start_at, coverage_end_at`,
    [input.userId, input.bindId, purchaseOrderId, input.premiumAmount, input.premiumUsd, input.coverageDelaySec, start, end]
  );

  const r = rows[0];
  return {
    purchaseOrderDbId: String(r.id),
    purchaseOrderId: r.purchase_order_id,
    premiumAmount: r.premium_amount,
    premiumUsd: r.premium_usd,
    coverageDelaySec: r.coverage_delay_sec,
    coverageStartAt: r.coverage_start_at,
    coverageEndAt: r.coverage_end_at,
  };
}
```

---

## 3.4 markOrderPaid（幂等：txHash 唯一 + 状态机推进）

```ts
// src/db/purchaseOrdersRepo.ts (继续)
export async function markOrderPaid(input: {
  purchaseOrderId: string;  // 0x...
  payTxHash: string;        // 0x...
  payer?: string;
}) {
  // 幂等：同一个 purchaseOrderId 已有 payTxHash 直接返回 ok
  const { rows: cur } = await pool.query(
    `select status, pay_tx_hash from purchase_orders where purchase_order_id=$1`,
    [input.purchaseOrderId]
  );
  if (cur.length === 0) throw new Error("ORDER_NOT_FOUND");
  if (cur[0].pay_tx_hash) {
    if (cur[0].pay_tx_hash === input.payTxHash) return { ok: true, status: cur[0].status };
    throw new Error("ORDER_ALREADY_HAS_DIFFERENT_TX");
  }

  // 更新：利用 uniq_pay_tx_hash 防重复 tx
  const { rows } = await pool.query(
    `update purchase_orders
     set pay_tx_hash=$2,
         payer=coalesce($3,payer),
         status='PAID_PENDING_CONFIRM'
     where purchase_order_id=$1 and pay_tx_hash is null
     returning status`,
    [input.purchaseOrderId, input.payTxHash, input.payer ?? null]
  );

  if (rows.length === 0) throw new Error("ORDER_PAY_UPDATE_FAILED");
  return { ok: true, status: rows[0].status };
}
```

---

# 4) 把 routes/insurance.ts 接上 repo（你现在就能跑）

你报告里这几个是 “待实现抛错”，替换成上面的 repo 调用即可：

* `getApiAccount` -> `apiAccountsRepo.getApiAccount`
* `createOrGetBinding` -> `bindingsRepo.createOrGetBinding`
* `createPurchaseOrder` -> `purchaseOrdersRepo.createPurchaseOrder`
* `markOrderPaid` -> `purchaseOrdersRepo.markOrderPaid`

并且 **create-order 不要硬编码 3 USD** 的方式也能先跑，但至少把 durationSec 跟 SKU 绑定：

* 8h = 8*3600
* 24h = 24*3600
* 30d = 30*24*3600

---

# 5) 你现在最关键的验收清单（今天就能闭环）

1. Step3 `GET /api/okx/positions` 成功返回
2. 点“选择投保仓位” -> `POST /api/insurance/bind-position` 返回 bindId
3. 点“生成投保订单” -> `POST /api/insurance/create-order` 返回 purchaseOrderId + premiumAmount
4. 前端 approve+payPremium 上链
5. `POST /api/insurance/submit-payment` 写入 txHash（幂等）

做到这 5 条，你保险区就从“样子货”变成“能收钱能对账”的机器。

---

## 你回我两行信息，我就把 routes 改法按你仓库风格精确贴出来

1. 你现在用的是 **pg** 还是 **sqlite / drizzle / prisma**？
2. `user_id` 你准备用什么（钱包地址？还是系统用户表 id）？

你不回也行：我默认 `pg + user_id=钱包地址`，继续往下给你把 routes 拼好。
