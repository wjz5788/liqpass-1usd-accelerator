下面是你要的“在画布中实现”：**右侧 YES/NO 改为 1–99 滑条**，并且 **滑条与左侧 Chart Tab 联动**（用 QuoteService 返回的 pNow/pAfter/expectedCost 驱动）。

我按“最小侵入、你现有结构不大动”的方式做：

* 保留你 `useDocDetailLayout` 的页面骨架
* **右侧 sticky**：把 `Milestone Trade` 卡替换为 `MoveProbPanel`
* 左侧 `Chart` Tab：用一个新组件 `ProbCurveMini` 显示曲线 + 当前点 + target 点

---

# A) 新增联动图表组件

**文件：`src/components/ProbCurveMini.tsx`**（路径你自己按项目习惯放）

```tsx
import React, { useMemo } from "react";
import { wadToPct } from "@/utils/format";

type Props = {
  pNowWad: string;   // 1e18
  pAfterWad: string; // 1e18
  targetPct: number; // 1..99
  bLabel?: string;   // optional display like "b=60"
};

function wadToUnit(wadStr: string) {
  const n = Number(wadStr);
  if (!Number.isFinite(n)) return 0.5;
  return Math.max(0, Math.min(1, n / 1e18));
}

export default function ProbCurveMini({ pNowWad, pAfterWad, targetPct, bLabel }: Props) {
  const pNow = wadToUnit(pNowWad);
  const pAfter = wadToUnit(pAfterWad);

  // SVG params
  const W = 800;
  const H = 240;
  const padL = 60;
  const padR = 60;
  const padT = 20;
  const padB = 40;

  const xPct = (pct: number) => padL + ((pct - 1) / 98) * (W - padL - padR);
  const yProb = (p: number) => padT + (1 - p) * (H - padT - padB);

  const xNow = xPct(Math.round(pNow * 100));
  const yNow = yProb(pNow);
  const xAfter = xPct(targetPct);
  const yAfter = yProb(pAfter);

  const pathD = useMemo(() => {
    // 你之前示意那种“中间略下凹”的曲线骨架
    const y0 = yProb(pNow);
    const midX = (padL + (W - padR)) / 2;
    const midY = Math.min(H - padB, y0 + 40);
    return `M ${padL} ${y0} Q ${midX} ${midY} ${W - padR} ${y0}`;
  }, [pNow]);

  return (
    <div className="w-full h-full">
      <div className="flex justify-between items-center mb-3">
        <div className="font-bold text-stripe-900">价格/概率曲线</div>
        <div className="text-sm font-medium text-stripe-500">{bLabel ?? ""}</div>
      </div>

      <svg viewBox={`0 0 ${W} ${H}`} className="w-full h-[280px]">
        {/* axes */}
        <line x1={padL} y1={H - padB} x2={W - padR} y2={H - padB} stroke="#E5E7EB" strokeWidth="1" />
        <line x1={padL} y1={padT} x2={padL} y2={H - padB} stroke="#E5E7EB" strokeWidth="1" />

        {/* y ticks */}
        {[0, 0.25, 0.5, 0.75, 1].map((p) => {
          const y = yProb(p);
          const label = Math.round(p * 100);
          return (
            <g key={p}>
              <line x1={padL - 2} y1={y} x2={padL} y2={y} stroke="#E5E7EB" strokeWidth="1" />
              <text x={padL - 8} y={y + 4} textAnchor="end" fontSize="10" fill="#6B7280">{label}</text>
            </g>
          );
        })}

        {/* x ticks: 1..99 sparse */}
        {[1, 25, 50, 75, 99].map((v) => {
          const x = xPct(v);
          return (
            <g key={v}>
              <line x1={x} y1={H - padB} x2={x} y2={H - padB + 2} stroke="#E5E7EB" strokeWidth="1" />
              <text x={x} y={H - 12} textAnchor="middle" fontSize="10" fill="#6B7280">{v}</text>
            </g>
          );
        })}

        {/* base curve */}
        <path d={pathD} fill="none" stroke="#CBD5E1" strokeWidth="2" />

        {/* target vertical line */}
        <line x1={xAfter} y1={padT} x2={xAfter} y2={H - padB} stroke="#D1FAE5" strokeWidth="2" />

        {/* current dot */}
        <circle cx={xNow} cy={yNow} r={5} fill="#111827" />
        <text x={xNow + 8} y={yNow - 8} fontSize="10" fill="#111827">now</text>

        {/* after dot */}
        <circle cx={xAfter} cy={yAfter} r={6} fill="#10B981" />
        <text x={xAfter + 8} y={yAfter - 8} fontSize="10" fill="#059669">target</text>
      </svg>

      <div className="flex items-center justify-between mt-2">
        <div className="text-sm text-stripe-500">
          Current: <span className="font-bold text-stripe-900">{wadToPct(pNowWad)}</span>
        </div>
        <div className="text-sm text-stripe-500">
          After: <span className="font-bold text-green-600">{wadToPct(pAfterWad)}</span>
        </div>
      </div>
    </div>
  );
}
```

---

# B) 让 MoveProbPanel 把 target/quote 回传父组件（联动关键）

如果你已经用我上一条给你的“受控模式”版本，就跳过。

**文件：`src/components/MoveProbPanel.tsx`**

* 增加：`targetPct? / onTargetPctChange? / onQuoteChange?`
* 在 `fetchQuote` 成功后 `onQuoteChange(resp)`

（我不在这里重复整份代码了，你直接用你画布里那份“受控版 MoveProbPanel”。）

---

# C) 在 OneDollarProjectPageLikePump 内真正接起来

你现在的 doc-detail 右侧 sticky 里是：

* Milestone Trade 卡（YES/NO）
* UserEarningsCard
* MoneyFlowCard

我们把第一块替换成 MoveProbPanel，并把 quote 状态拿来驱动左侧 Chart Tab。

## C1) 顶部 import

在你的 `OneDollarProjectPageLikePump.tsx` 顶部加：

```tsx
import MoveProbPanel from "@/components/MoveProbPanel";
import ProbCurveMini from "@/components/ProbCurveMini";
import type { QuoteResponse } from "@/api/quote";
```

> 如果你不用 `@/` 别名，就改成相对路径。

## C2) 在组件 state 区域新增联动状态

放在 `useDocDetailLayout` 分支外层也行，放在分支内更干净。

```tsx
const [moveTargetPct, setMoveTargetPct] = useState<number>(50);
const [moveQuote, setMoveQuote] = useState<QuoteResponse | null>(null);

// 让图表有默认值（没 quote 时也能画）
const pNowWad = moveQuote?.pNow ?? String(Math.round(0.5 * 1e18));
const pAfterWad = moveQuote?.pAfter ?? String(Math.round((moveTargetPct / 100) * 1e18));
```

## C3) 左侧 Chart Tab 替换为联动图表

你当前 `activeTab === 'chart'` 里是固定 SVG + 50%。
直接替换成：

```tsx
{activeTab === 'chart' && (
  <div className='p-4 h-[340px] bg-white'>
    <ProbCurveMini
      pNowWad={pNowWad}
      pAfterWad={pAfterWad}
      targetPct={moveTargetPct}
      bLabel={`b=${effectiveB.toFixed(1)}`}
    />
  </div>
)}
```

## C4) 右侧 sticky：用 MoveProbPanel 替换 YES/NO

在 doc-detail 的右侧这里：

```tsx
<div className='lg:col-span-1'>
  <div className='sticky top-24 flex flex-col gap-4'>
    <div className='card overflow-hidden'>
      ... Milestone Trade ...
    </div>
    <UserEarningsCard ... />
    <MoneyFlowCard ... />
  </div>
</div>
```

把 `Milestone Trade` 整块替换为：

```tsx
<div className='card overflow-hidden'>
  <MoveProbPanel
    marketId={("0x" + "22".repeat(32)) as `0x${string}`}
    trader={("0x" + "33".repeat(20)) as `0x${string}`}

    // 受控联动
    targetPct={moveTargetPct}
    onTargetPctChange={(pct) => setMoveTargetPct(pct)}
    onQuoteChange={(q) => setMoveQuote(q)}

    defaultTargetPct={50}
    onSubmitQuote={(resp) => {
      console.log("quote ready for chain tx:", resp);
      // 你之后在这里接：合约 tx + signature
    }}
  />
</div>
```

> 这里的 `marketId/trader` 先写死占位。
> 你后续要把 milestone 变成不同 market：只要把 `marketId` 换成 `selectedMilestoneKey` 对应的 bytes32 即可。

---

# D) 你会立刻看到的效果 ✅

* 右侧：只剩一个“Move Probability”滑条（1–99）+ 报价（expectedCost/maxCost）
* 你拖动滑条：右侧立刻发 `fetchQuote`（debounce），同时 **左侧 Chart Tab 的绿色 target 点跟着移动**
* 以后接链上：只需要把 `onSubmitQuote` 里换成 `writeContract()` 或 `ethers` tx

---

# E) 如果你要“默认打开 Chart Tab”

想让用户一进来就看到联动图，而不是 Video：

```tsx
const [activeTab, setActiveTab] = useState<'video' | 'website' | 'github' | 'chart'>('chart')
```

---

如果你愿意再更进一步（但还是小改动）：

* 在 `Milestones` 列表点击某个 milestone 时，自动把右侧 marketId 切换，并且把 `moveTargetPct` reset 到该 milestone 的 `pYes*100`。这样“点行看详情 + 右侧滑条交易”会更像真实产品。
