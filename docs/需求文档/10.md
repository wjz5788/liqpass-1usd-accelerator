看懂了：你贴的这段是**保险后端的“订单仓储层（repo）”写法**（`pool.query + 幂等 + crypto id`），很好用。**1 美元后端（路径 C：后端签名报价）**建议就按同一套路写，放在 `apps/liqpass-backend` 里新增一个 **accelerator 模块**，结构/风格跟你这段保持一致。

下面我直接给你一套“能落地”的改造方案：**要建哪些表、写哪些文件、每个函数长什么样**。

---

## 0) 你现在贴的代码能复用的点（确定）

* `pool.query(...)` 这种 repo 风格完全适合 1USD：

  * 生成 id / nonce
  * 幂等（同一个 nonce 不重复签）
  * 状态更新（audit log）
* `crypto.randomBytes` 同样可用来做 quoteId / requestId（可选）

---

## 1) 1USD 后端最小职责（路径 C）

只干三件事（别做多）：

1. **读链上市场状态**：`b/qYes/qNo/closeTime/outcome`
2. **算报价**：buy 的 `cost`、sell 的 `payout`（先按 LMSR 算，最稳）
3. **签名**：EIP-712 签名返回给前端；并做 **nonce 防重放** + **审计落库**

---

## 2) Postgres 最小加两张表（照你 repo 风格写）

### 表 A：用户 nonce（递增）

```sql
create table if not exists accelerator_nonce (
  user_address text primary key,
  next_nonce bigint not null default 1,
  updated_at timestamptz not null default now()
);
```

### 表 B：报价审计（强烈建议）

```sql
create table if not exists accelerator_quote_audit (
  id bigserial primary key,
  user_address text not null,
  market_address text not null,
  is_buy boolean not null,
  is_yes boolean not null,
  shares_amount numeric not null,   -- 最小单位（1e6）
  quote_amount numeric not null,    -- cost 或 payout，最小单位（1e6）
  expiry bigint not null,
  nonce bigint not null,
  sig text not null,
  algo text not null default 'LMSR',
  created_at timestamptz not null default now()
);

create index if not exists idx_acc_quote_user on accelerator_quote_audit(user_address);
create index if not exists idx_acc_quote_market on accelerator_quote_audit(market_address);
```

> 你现在保险表里已经有“订单”概念；1USD 这里不需要订单状态机，**只要 audit**。

---

## 3) Repo：nonce（完全照你现在 repo 写法）

新建：`apps/liqpass-backend/src/domains/accelerator/nonceRepo.ts`

```ts
import { pool } from "../db/pool.js"; // 按你实际路径改
import { ethers } from "ethers";

export async function nextNonce(user: string): Promise<bigint> {
  const u = ethers.getAddress(user);

  // 事务 + FOR UPDATE，避免并发发两次同 nonce
  const client = await pool.connect();
  try {
    await client.query("BEGIN");

    const cur = await client.query(
      `select next_nonce from accelerator_nonce where user_address=$1 for update`,
      [u]
    );

    let nonce: bigint;
    if (cur.rows.length === 0) {
      nonce = 1n;
      await client.query(
        `insert into accelerator_nonce(user_address, next_nonce) values($1,$2)`,
        [u, "2"]
      );
    } else {
      nonce = BigInt(cur.rows[0].next_nonce);
      await client.query(
        `update accelerator_nonce set next_nonce=$2, updated_at=now() where user_address=$1`,
        [u, (nonce + 1n).toString()]
      );
    }

    await client.query("COMMIT");
    return nonce;
  } catch (e) {
    await client.query("ROLLBACK");
    throw e;
  } finally {
    client.release();
  }
}
```

---

## 4) Service：读链上市场状态（ethers）

新建：`apps/liqpass-backend/src/domains/accelerator/marketState.ts`

```ts
import { ethers } from "ethers";

const ABI = [
  "function b() view returns (uint256)",
  "function qYes() view returns (uint256)",
  "function qNo() view returns (uint256)",
  "function closeTime() view returns (uint64)",
  "function outcome() view returns (uint8)"
];

export async function getMarketState(provider: ethers.Provider, market: string) {
  const addr = ethers.getAddress(market);
  const c = new ethers.Contract(addr, ABI, provider);

  const [b, qYes, qNo, closeTime, outcome] = await Promise.all([
    c.b(), c.qYes(), c.qNo(), c.closeTime(), c.outcome()
  ]);

  return {
    market: addr,
    b: BigInt(b.toString()),
    qYes: BigInt(qYes.toString()),
    qNo: BigInt(qNo.toString()),
    closeTime: Number(closeTime),
    outcome: Number(outcome),
  };
}
```

---

## 5) Service：LMSR 算 cost / payout（后端算）

JS 里不要用 `number`，用 `decimal.js`（建议加依赖）。

安装：

```bash
npm i decimal.js
```

新建：`apps/liqpass-backend/src/domains/accelerator/lmsrMath.ts`

```ts
import Decimal from "decimal.js";

/**
 * 所有输入输出都用“最小单位”（USDC 1e6）的整数（bigint）
 * 返回也是最小单位（向上取整）
 */
function D(x: bigint) { return new Decimal(x.toString()); }

export function lmsrCostDelta(params: {
  b: bigint;
  qYes: bigint;
  qNo: bigint;
  dq: bigint;
  addToYes: boolean;
}): bigint {
  const { b, qYes, qNo, dq, addToYes } = params;

  const before = cost({ b, qYes, qNo });
  const after = cost({
    b,
    qYes: addToYes ? (qYes + dq) : qYes,
    qNo:  addToYes ? qNo : (qNo + dq),
  });

  const delta = after.minus(before);
  if (delta.lte(0)) throw new Error("BAD_DELTA");
  return BigInt(delta.ceil().toString());
}

export function lmsrPayoutDelta(params: {
  b: bigint;
  qYes: bigint;
  qNo: bigint;
  dq: bigint;
  sellYes: boolean;
}): bigint {
  const { b, qYes, qNo, dq, sellYes } = params;

  const before = cost({ b, qYes, qNo });
  const after = cost({
    b,
    qYes: sellYes ? (qYes - dq) : qYes,
    qNo:  sellYes ? qNo : (qNo - dq),
  });

  const delta = before.minus(after);
  if (delta.lte(0)) throw new Error("BAD_PAYOUT");
  return BigInt(delta.ceil().toString());
}

function cost(input: { b: bigint; qYes: bigint; qNo: bigint }) {
  const b = D(input.b);
  const y = D(input.qYes).div(b);
  const n = D(input.qNo).div(b);

  // b * ln(exp(y) + exp(n))
  const sum = Decimal.exp(y).plus(Decimal.exp(n));
  return b.mul(Decimal.ln(sum));
}
```

> 这就是路径 C 的核心：**后端算 ΔC/Δpayout，然后签名**。
> 你后面换 RSMR，只改这里就行。

---

## 6) Service：EIP-712 签名（后端）

你已经用 ethers 了，直接签 typed data。
新建：`apps/liqpass-backend/src/domains/accelerator/signQuote.ts`

```ts
import { ethers } from "ethers";

export const types = {
  Quote: [
    { name: "user", type: "address" },
    { name: "isBuy", type: "bool" },
    { name: "isYes", type: "bool" },
    { name: "shares", type: "uint256" }, // 最小单位
    { name: "amount", type: "uint256" }, // cost/payout 最小单位
    { name: "expiry", type: "uint64" },
    { name: "nonce", type: "uint256" },
  ],
};

export async function signQuote(params: {
  signer: ethers.Wallet;
  provider: ethers.Provider;
  verifyingContract: string;  // 市场合约地址
  user: string;
  isBuy: boolean;
  isYes: boolean;
  sharesSmallest: bigint;
  amountSmallest: bigint;
  expiry: number;
  nonce: bigint;
}) {
  const chainId = (await params.provider.getNetwork()).chainId;

  const domain = {
    name: "LMSRCompleteSetMarket",
    version: "1",
    chainId,
    verifyingContract: ethers.getAddress(params.verifyingContract),
  };

  const value = {
    user: ethers.getAddress(params.user),
    isBuy: params.isBuy,
    isYes: params.isYes,
    shares: params.sharesSmallest.toString(),
    amount: params.amountSmallest.toString(),
    expiry: params.expiry,
    nonce: params.nonce.toString(),
  };

  const sig = await params.signer.signTypedData(domain, types, value);
  return { domain, value, sig };
}
```

> **关键**：domain `name/version` 必须和你合约里写的一致；否则验签失败。

---

## 7) Fastify 路由：/quote/buy /quote/sell（照你现有风格）

你已经有模块化路由，那就加一个 `accelerator/routes.ts`，核心逻辑就是串起来：

* `state = getMarketState()`
* `nonce = nextNonce(user)`
* `cost = lmsrCostDelta(...)` 或 `payout = lmsrPayoutDelta(...)`
* `sig = signQuote(...)`
* 落库 audit
* 返回给前端

---

## 8) 你贴的 `src/` 目录是前端，不是后端（避免走错）

你发的 `~/Desktop/mvp/liqpass-1usd-accelerator/src` 目录（pages/components/hooks）明显是 **前端 Vite/React**。
**后端**请在：`apps/liqpass-backend/` 里加 `domains/accelerator`（别加到前端 src 里）。

---

## 你现在要做的最小动作（一步到位）

1. 在后端加上面两张表（migration）
2. 把 5 个文件加进去：`nonceRepo / marketState / lmsrMath / signQuote / routes`
3. 配好：

   * Base RPC
   * `QUOTE_SIGNER_PK`（后端签名私钥）
4. 前端调用 `/quote/buy` 拿签名，再调合约 `buyWithQuote`

---

如果你想我“按你现有项目结构精确落位”，你再贴两段就够（不用全仓库）：

1. `apps/liqpass-backend/src/app.ts`（或 main/server.ts）里**路由是怎么 register 的**
2. `pool.js` 在哪（路径）和导出方式（你现在贴的是 `import { pool } from './pool.js'`，我需要看它所在目录层级）

我就能把上述模块按你实际目录写成“直接复制到你仓库就能跑”的版本。
