收到，直接把 **A+B+C** 给你一套“能跑通”的最小闭环：**Step3 选仓位 → 绑定 → Step4 生成投保订单 → USDC 支付 → 回填订单/事件对账**。

下面代码你按模块拷进去就行（你是 Vite+React + Node/Express 的话最合适）。

---

# A) Step 3 前端：拉仓位 + 绑定投保对象（React/TS）

### 1) types（前端标准化结构）

```ts
// src/types/okx.ts
export type OkxPosition = {
  instId: string;      // BTC-USDT-SWAP
  mgnMode: "isolated" | "cross";
  posSide: "long" | "short" | "net";
  ccy?: string;
  lever: number;
  pos: string;
  avgPx?: string;
  markPx?: string;
  liqPx?: string;
  uplRatio?: string;
};
```

### 2) Step3 组件（选仓位 + bind）

```tsx
// src/pages/Insurance/Step3BindPosition.tsx
import React, { useEffect, useState } from "react";
import type { OkxPosition } from "@/types/okx";

type Props = {
  apiAccountId: string;              // Step1 保存API后返回的id
  onBound: (bind: { bindId: string }) => void;
};

export default function Step3BindPosition({ apiAccountId, onBound }: Props) {
  const [instIdFilter, setInstIdFilter] = useState("");
  const [positions, setPositions] = useState<OkxPosition[]>([]);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);
  const [sku, setSku] = useState<"LIQPASS_8H" | "LIQPASS_24H" | "DD_30D">("LIQPASS_24H");

  async function loadPositions() {
    setLoading(true); setErr(null);
    try {
      const qs = new URLSearchParams({ apiAccountId });
      if (instIdFilter.trim()) qs.set("instId", instIdFilter.trim());
      const res = await fetch(`/api/okx/positions?${qs.toString()}`);
      if (!res.ok) throw new Error(await res.text());
      const data = await res.json();
      setPositions(data.positions as OkxPosition[]);
    } catch (e: any) {
      setErr(e?.message ?? "LOAD_POSITIONS_FAILED");
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => { loadPositions(); }, []);

  async function bindPosition(p: OkxPosition) {
    setLoading(true); setErr(null);
    try {
      const res = await fetch("/api/insurance/bind-position", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          apiAccountId,
          instId: p.instId,
          mgnMode: p.mgnMode,
          posSide: p.posSide === "net" ? "net" : p.posSide,
          sku,
        }),
      });
      if (!res.ok) throw new Error(await res.text());
      const data = await res.json();
      onBound({ bindId: data.bindId });
    } catch (e: any) {
      setErr(e?.message ?? "BIND_FAILED");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="space-y-4">
      <div className="p-4 rounded-lg border bg-white">
        <div className="font-semibold">Step 3：选择要绑定的合约仓位（instId + mgnMode + posSide）</div>
        <div className="text-sm text-gray-600 mt-1">只读拉取仓位，不下单不平仓。</div>
      </div>

      <div className="p-4 rounded-lg border bg-white space-y-3">
        <div className="flex gap-2">
          <input
            className="border rounded px-3 py-2 flex-1"
            placeholder="可选：固定交易对，如 BTC-USDT-SWAP"
            value={instIdFilter}
            onChange={(e) => setInstIdFilter(e.target.value)}
          />
          <button className="px-4 py-2 rounded bg-black text-white" onClick={loadPositions} disabled={loading}>
            刷新
          </button>
        </div>

        <div className="flex gap-2 items-center">
          <span className="text-sm text-gray-600">选择SKU：</span>
          <select className="border rounded px-2 py-2" value={sku} onChange={(e) => setSku(e.target.value as any)}>
            <option value="LIQPASS_8H">8h 时段保</option>
            <option value="LIQPASS_24H">24h 当日爆仓保</option>
            <option value="DD_30D">30天回撤保</option>
          </select>
        </div>

        {err && <div className="text-sm text-red-600">{err}</div>}
        {loading && <div className="text-sm text-gray-600">加载中…</div>}

        <div className="space-y-3">
          {positions.map((p, idx) => (
            <div key={idx} className="border rounded-lg p-4">
              <div className="flex justify-between">
                <div className="font-semibold">{p.instId}</div>
                <div className="text-sm">
                  <span className="px-2 py-1 rounded border mr-2">{p.mgnMode}</span>
                  <span className="px-2 py-1 rounded border">{p.posSide}</span>
                </div>
              </div>

              <div className="grid grid-cols-2 gap-2 mt-3 text-sm text-gray-700">
                <div>杠杆：{p.lever}x</div>
                <div>持仓：{p.pos}</div>
                <div>均价：{p.avgPx ?? "-"}</div>
                <div>标记：{p.markPx ?? "-"}</div>
                <div>强平：{p.liqPx ?? "-"}</div>
                <div>浮动：{p.uplRatio ?? "-"}</div>
              </div>

              <div className="mt-3">
                <button
                  className="px-4 py-2 rounded bg-black text-white"
                  onClick={() => bindPosition(p)}
                  disabled={loading}
                >
                  选择投保这个仓位
                </button>
              </div>
            </div>
          ))}
          {(!loading && positions.length === 0) && (
            <div className="text-sm text-gray-600">未读取到仓位：要么没有仓位，要么 Read 权限/账户不一致。</div>
          )}
        </div>
      </div>
    </div>
  );
}
```

---

# B) 后端：OKX positions 拉取 + bind-position（Express/TS）

## 1) OKX 签名 + positions

```ts
// src/services/okxClient.ts
import crypto from "crypto";
import axios from "axios";

function okxSign(ts: string, method: string, path: string, body: string, secret: string) {
  const prehash = ts + method + path + body;
  return crypto.createHmac("sha256", secret).update(prehash).digest("base64");
}

export async function okxGetPositions(opts: {
  apiKey: string; secret: string; passphrase: string;
  instId?: string;
}) {
  const method = "GET";
  const path = opts.instId
    ? `/api/v5/account/positions?instId=${encodeURIComponent(opts.instId)}`
    : `/api/v5/account/positions`;

  const ts = new Date().toISOString();
  const sign = okxSign(ts, method, path, "", opts.secret);

  const res = await axios.get(`https://www.okx.com${path}`, {
    headers: {
      "OK-ACCESS-KEY": opts.apiKey,
      "OK-ACCESS-SIGN": sign,
      "OK-ACCESS-TIMESTAMP": ts,
      "OK-ACCESS-PASSPHRASE": opts.passphrase,
    },
    timeout: 8000,
  });

  if (res.data?.code !== "0") throw new Error(`OKX_ERROR:${res.data?.msg ?? "UNKNOWN"}`);
  return res.data.data as any[];
}
```

## 2) 路由：GET positions + POST bind-position

```ts
// src/routes/insurance.ts
import express from "express";
import { okxGetPositions } from "../services/okxClient";

const r = express.Router();

// 你自己的存储：api_accounts 表（加密后的 key/secret/passphrase/uid）
async function getApiAccount(apiAccountId: string) {
  // TODO: 从DB取出来并解密
  // return { id, uid, apiKey, secret, passphrase, exchange:"OKX" }
  throw new Error("IMPLEMENT_DB:getApiAccount");
}

async function createOrGetBinding(input: {
  apiAccountId: string;
  instId: string;
  mgnMode: string;
  posSide: string;
  sku: string;
}) {
  // TODO: insert insured_bindings (DRAFT) with unique constraint
  // return { bindId }
  throw new Error("IMPLEMENT_DB:createOrGetBinding");
}

r.get("/okx/positions", async (req, res) => {
  try {
    const apiAccountId = String(req.query.apiAccountId || "");
    const instId = req.query.instId ? String(req.query.instId) : undefined;
    if (!apiAccountId) return res.status(400).send("MISSING_apiAccountId");

    const acct = await getApiAccount(apiAccountId);

    const raw = await okxGetPositions({
      apiKey: acct.apiKey,
      secret: acct.secret,
      passphrase: acct.passphrase,
      instId,
    });

    // 标准化（前端用）
    const positions = raw.map((p) => ({
      instId: p.instId,
      mgnMode: p.mgnMode,
      posSide: p.posSide || "net",
      ccy: p.ccy,
      lever: Number(p.lever || 0),
      pos: p.pos,
      avgPx: p.avgPx,
      markPx: p.markPx,
      liqPx: p.liqPx,
      uplRatio: p.uplRatio,
    }));

    res.json({ positions });
  } catch (e: any) {
    res.status(400).send(e?.message ?? "POS_FAILED");
  }
});

r.post("/insurance/bind-position", async (req, res) => {
  try {
    const { apiAccountId, instId, mgnMode, posSide, sku } = req.body || {};
    if (!apiAccountId || !instId || !mgnMode || !posSide || !sku) {
      return res.status(400).send("MISSING_FIELDS");
    }

    // 最关键：绑定键冻结
    const out = await createOrGetBinding({ apiAccountId, instId, mgnMode, posSide, sku });
    res.json({ bindId: out.bindId });
  } catch (e: any) {
    res.status(400).send(e?.message ?? "BIND_FAILED");
  }
});

export default r;
```

---

# C) Step 4：生成投保订单 + 调 USDC Checkout 合约（前后端+链上）

## 0) 你需要一个“投保订单 draft”接口

后端生成订单：算保费、锁定生效时间（+10分钟）、返回给前端用于链上支付。

### 后端：POST /insurance/create-order

```ts
// 在 src/routes/insurance.ts 里继续加
async function createPurchaseOrder(input: {
  bindId: string;
  premiumUsd: string;     // e.g. "3.5"
  premiumAmount: string;  // USDC 最小单位字符串，6位： "3500000"
  coverageDelaySec: number;
}) {
  // TODO: insert purchase_orders (status=DRAFT)
  // return { purchaseOrderId, premiumAmount, coverageStartAt, coverageEndAt }
  throw new Error("IMPLEMENT_DB:createPurchaseOrder");
}

r.post("/insurance/create-order", async (req, res) => {
  try {
    const { bindId } = req.body || {};
    if (!bindId) return res.status(400).send("MISSING_bindId");

    // TODO: 根据 bindId 读取 sku、仓位、杠杆等，算保费
    // 这里先给最小可跑：前期你也说“半自动”，可以先写死或后端简单定价
    const premiumUsd = "3.00";
    const premiumAmount = "3000000"; // 3 USDC (6 decimals)
    const coverageDelaySec = 600;

    const out = await createPurchaseOrder({ bindId, premiumUsd, premiumAmount, coverageDelaySec });
    res.json(out);
  } catch (e: any) {
    res.status(400).send(e?.message ?? "CREATE_ORDER_FAILED");
  }
});
```

---

## 1) 合约接口：CheckoutUSDC 最小 ABI（你按自己合约函数名对齐）

你之前的方向是：`transferFrom(buyer -> TREASURY)` + emit `PremiumPaid`。

我建议你把支付函数定成：

* `payPremium(bytes32 purchaseOrderId, uint256 amount)`
  事件：
* `event PremiumPaid(address payer, bytes32 purchaseOrderId, uint256 amount);`

前端 ABI（如果你函数名不同，改一下即可）：

```ts
// src/web3/checkoutAbi.ts
export const checkoutAbi = [
  {
    type: "function",
    name: "payPremium",
    stateMutability: "nonpayable",
    inputs: [
      { name: "purchaseOrderId", type: "bytes32" },
      { name: "amount", type: "uint256" }
    ],
    outputs: []
  },
  {
    type: "event",
    name: "PremiumPaid",
    inputs: [
      { indexed: true, name: "payer", type: "address" },
      { indexed: true, name: "purchaseOrderId", type: "bytes32" },
      { indexed: false, name: "amount", type: "uint256" }
    ]
  }
] as const;

export const usdcAbi = [
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bool" }]
  }
] as const;
```

---

## 2) Step4 前端：创建订单 → approve → payPremium（wagmi/viem）

```tsx
// src/pages/Insurance/Step4Pay.tsx
import React, { useEffect, useState } from "react";
import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { parseUnits, toHex } from "viem";
import { checkoutAbi, usdcAbi } from "@/web3/checkoutAbi";

type Props = { bindId: string; checkoutAddress: `0x${string}`; usdcAddress: `0x${string}`; onPaid: () => void; };

export default function Step4Pay({ bindId, checkoutAddress, usdcAddress, onPaid }: Props) {
  const { address } = useAccount();
  const [order, setOrder] = useState<any>(null);
  const [err, setErr] = useState<string | null>(null);

  const approveWrite = useWriteContract();
  const payWrite = useWriteContract();

  const approveWait = useWaitForTransactionReceipt({ hash: approveWrite.data });
  const payWait = useWaitForTransactionReceipt({ hash: payWrite.data });

  useEffect(() => {
    (async () => {
      setErr(null);
      const res = await fetch("/api/insurance/create-order", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ bindId }),
      });
      if (!res.ok) { setErr(await res.text()); return; }
      const data = await res.json();
      setOrder(data);
    })();
  }, [bindId]);

  async function doApprove() {
    setErr(null);
    const amt = BigInt(order.premiumAmount); // 已是6位最小单位
    await approveWrite.writeContractAsync({
      address: usdcAddress,
      abi: usdcAbi,
      functionName: "approve",
      args: [checkoutAddress, amt],
    });
  }

  async function doPay() {
    setErr(null);
    const amt = BigInt(order.premiumAmount);

    // purchaseOrderId 建议后端直接返回 bytes32；这里给你一个最简单可跑：把字符串转bytes32（32字节）
    // 更稳：后端就存 bytes32，并返回 "0x..." 形式
    const po = order.purchaseOrderId as `0x${string}`;

    await payWrite.writeContractAsync({
      address: checkoutAddress,
      abi: checkoutAbi,
      functionName: "payPremium",
      args: [po, amt],
    });
  }

  // 支付成功后：回填后端（记录 txHash 用于对账/幂等）
  useEffect(() => {
    (async () => {
      if (!payWait.isSuccess || !payWrite.data) return;
      await fetch("/api/insurance/submit-payment", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          purchaseOrderId: order.purchaseOrderId,
          payTxHash: payWrite.data,
          payer: address,
        }),
      });
      onPaid();
    })();
  }, [payWait.isSuccess]);

  if (!order) return <div className="p-4">生成订单中…</div>;

  return (
    <div className="space-y-4 p-4 border rounded-lg bg-white">
      <div className="text-xl font-semibold">Step 4：支付保费（USDC）</div>
      <div className="text-sm text-gray-700">
        订单：{order.purchaseOrderId}<br/>
        保费：{order.premiumUsd} USDC<br/>
        生效：购买后 +{order.coverageDelaySec}s
      </div>

      {err && <div className="text-sm text-red-600">{err}</div>}

      <div className="flex gap-2">
        <button className="px-4 py-2 rounded bg-black text-white" onClick={doApprove} disabled={approveWrite.isPending}>
          1) Approve USDC
        </button>
        <button className="px-4 py-2 rounded bg-black text-white" onClick={doPay} disabled={payWrite.isPending || !approveWait.isSuccess}>
          2) 支付保费
        </button>
      </div>

      <div className="text-xs text-gray-600">
        Approve：{approveWait.isSuccess ? "✅" : approveWrite.isPending ? "处理中…" : "-"}<br/>
        Pay：{payWait.isSuccess ? "✅" : payWrite.isPending ? "处理中…" : "-"}
      </div>
    </div>
  );
}
```

> 注意：我刻意让流程是 **Approve 成功后才能 Pay**，这样用户不容易卡死。

---

## 3) 后端：submit-payment（回填支付 txHash + 幂等）

```ts
// 在 src/routes/insurance.ts 继续加
async function markOrderPaid(input: { purchaseOrderId: string; payTxHash: string; payer?: string }) {
  // TODO: purchase_orders.status = PAID_PENDING_CONFIRM
  // TODO: unique(payTxHash) 防重复
  throw new Error("IMPLEMENT_DB:markOrderPaid");
}

r.post("/insurance/submit-payment", async (req, res) => {
  try {
    const { purchaseOrderId, payTxHash, payer } = req.body || {};
    if (!purchaseOrderId || !payTxHash) return res.status(400).send("MISSING_FIELDS");
    await markOrderPaid({ purchaseOrderId, payTxHash, payer });
    res.json({ ok: true });
  } catch (e: any) {
    res.status(400).send(e?.message ?? "SUBMIT_PAYMENT_FAILED");
  }
});
```

---

# 你现在立刻就能跑通的“闭环验收点”

1. Step1 保存 API
2. Step2 instId+ordId 验证通过（你之前的）
3. Step3 拉 positions 有数据，点击“选择投保这个仓位”拿到 bindId
4. Step4 create-order 返回 premiumAmount
5. 钱包 approve + payPremium 成功出 tx
6. submit-payment 回填 txHash
7. 后端监听 PremiumPaid 事件或用 txReceipt 二次确认，把订单改成 ACTIVE

---

# 下一刀（我建议你现在就做）

你回我一句：**“我合约函数名是啥 / 事件名是啥”**（贴一段 CheckoutUSDC 的支付函数和事件定义），我就把 Step4 的 ABI、purchaseOrderId bytes32 生成方式、以及后端监听事件的代码按你真实合约对齐，避免你改来改去。
