行，按“最省时间”打法：**不做链上监听、不做自动扫**，先把 **投保单→绑定OKX→手动标记已付款→用户点击理赔→管理员审核→手动打款并登记** 这一条闭环跑通。
你现在后端已经有“核验+审核”半条链路，我们补齐“投保单与支付状态”这半条就能跑。

---

## 0) 目标：1天内跑通的最小闭环（半自动）

**用户流程**

1. 前端创建投保单（返回 `purchaseOrderId`）
2. 用户把 OKX 的 `ordId + instId` 填进来绑定到投保单
3. 用户支付保费（先不监听链上，直接管理员/内部接口把这单标记 paid）
4. 用户点“发起理赔” → 调 `/internal/claims/onchain-trigger`（你现成的）
5. 管理员在 Admin 台 approve/reject/mark-paid
6. 你用多签/手动转账 USDC，转完把 `multisigTxHash` 填回去

---

## 1) 你后端需要新增的 4 个接口（最少）

在 `apps/liqpass-backend/src/index.ts` 里目前只注册了 claims routes：
你要加一个新文件 `src/routes/purchaseOrders.ts`，并注册它。

### (1) 创建投保单

`POST /api/purchase-orders`

**body（最小字段）**

```json
{
  "policyType": "OKX_24H",
  "chainId": 8453,
  "premiumAmountUsdc": "1.00",
  "policyParams": { "payout_fixed_usdc": "50", "payout_cap_usdc": "50" },
  "coverageStartAt": "2026-01-22T12:00:00Z",
  "coverageEndAt": "2026-01-23T12:00:00Z"
}
```

**返回**

```json
{ "purchaseOrderId": "uuid" }
```

> 最省时间策略：coverageStartAt/EndAt 先由前端传（你以后再改成后端计算 “now + 10min 开始, +24h 结束”）。

---

### (2) 绑定 OKX 订单信息（ordId/instId）

`POST /api/purchase-orders/:id/bind-okx`

**body**

```json
{ "ordId": "1234567890", "instId": "BTC-USDT-SWAP" }
```

写入 `purchase_orders.okx_meta_json = {"ordId": "...","instId":"..."}`

---

### (3) 标记已付款（半自动关键）

`POST /internal/purchase-orders/:id/mark-paid`

* 需要 header：`x-internal-key`（沿用你现在 internalClaims 的做法）
* body 可选：`paidAt`，不传就用 now

写入：

* `paid_at = now()`
* 可选写入：`quote_hash / premium_amount_usdc`（你现在 migration 已有字段）

---

### (4) 查询投保单（前端展示用）

`GET /api/purchase-orders/:id`

返回：

* `paid_at`
* `coverage_start_at/end_at`
* `okx_meta_json`
* `policy_params_json`

---

## 2) 数据库层：你只需要补 3 个 repo 方法

你现在只有 `getPurchaseOrderById()`。

新增到 `src/db/purchaseOrdersRepo.ts`：

* `createPurchaseOrder(...) -> id`
* `bindOkxMeta(id, {ordId, instId})`
* `markPurchaseOrderPaid(id, paidAt?)`

SQL 逻辑很简单，全部围绕 `purchase_orders` 这张表。

---

## 3) 这条链路怎么跟你现有的理赔路由拼起来

你现有的 `/internal/claims/onchain-trigger` 会检查：

* `po.paid_at` 必须存在（所以 mark-paid 必须做）
* `coverage_start_at/end_at` 必须存在（create 时必须写）
* `okx_meta_json` 必须含 ordId/instId（bind-okx 必须做）

满足这三条，立刻进入 jp-verify → VERIFIED_PENDING_REVIEW（你已经写好）。

---

## 4) 给开发的“执行清单”只要照抄

### 后端新增文件

* `apps/liqpass-backend/src/routes/purchaseOrders.ts`
* `apps/liqpass-backend/src/db/purchaseOrdersRepo.ts` 增方法
* `apps/liqpass-backend/src/index.ts` 注册新 routes

### 前端最小改动

* 买保险按钮：先 call `POST /api/purchase-orders` 拿到 id
* 绑定订单页面：提交 ordId/instId → `bind-okx`
* “我已付款”按钮（临时）：触发 `mark-paid`（先放到 admin/内部模式）
* 理赔按钮：调用你现有 `/internal/claims/onchain-trigger`

---

## 5) 你现在就能用的“最小跑通脚本”（不改前端也能测）

用 curl 直接打通：

1. 创建投保单
2. 绑定 okx
3. mark-paid
4. 触发理赔

（我不在这里贴一大堆 curl 了，你让开发按上面 4 个接口做完，你现有 `scripts/mock_trigger.ts` 也能接上。）

---

## 6) 最省时间的“底线风控”两条（立刻加）

不加会很容易被乱搞：

1. **mark-paid 必须 internal key**（你已经有模板）
2. `bind-okx` 只允许在 `paid_at IS NULL` 时绑定（防止事后换单）

---

如果你愿意，我可以直接按你现在的 Fastify 风格，把 `purchaseOrders.ts + repo methods` 的代码骨架（可直接粘贴）给出来，保证跟你现有 `internalClaims.ts` 风格一致、最少文件改动、一次就能跑。你要我按这个输出完整代码吗？
